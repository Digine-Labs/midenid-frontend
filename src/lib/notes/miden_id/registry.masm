use.miden::account
use.miden::note
use.std::sys

const.ALREADY_INITIALIZED="Already Initialized"
const.NOT_INITIALIZED="Contract not initialized"
const.OWNER_SUFFIX_MISMATCH="Owner suffix mismatch"
const.OWNER_PREFIX_MISMATCH="Owner prefix mismatch"
const.NAME_ALREADY_REGISTERED="Name already registered"
const.ACCOUNT_ALREADY_HAS_NAME="Account already has name"
const.VALIDATE_SUB_OVERFLOW="Payment validation overflow"
const.WRONG_AMOUNT_PAID="Payment insufficient: need more tokens"
const.NAME_LEN_HIGH="Maximum 20 characters"

const.MAX_NAME_LENGTH=20 # For now 20 then we maximize this limit

# Storage
# 0: Initialized flag
# 1: Owner
# 2: Payment Token
# 3: Name -> ID map
# 4: ID -> Name map
# 5: Price

# Input: [price, token_prefix, token_suffix]
# Output: []
export.init
    # Check that contract is not already initialized
    exec._assert_initialized
    # [price, token_prefix, token_suffix]

    # Mark contract as initialized
    exec._set_initialized
    # [price, token_prefix, token_suffix]

    # Build PRICE_WORD: We want Word [100, 0, 0, 0] at indices [0, 1, 2, 3]
    # account::set_item stores stack positions in REVERSE: [index, V1, V2, V3, V4] â†’ Word[V4, V3, V2, V1]
    # So to get [100, 0, 0, 0] we need stack: [5, 0, 0, 0, 100, ...]
    # Current: [price, token_prefix, token_suffix]
    # Target: [5, 0, 0, 0, price, token_prefix, token_suffix]
    dup.0
    # [price, price, token_prefix, token_suffix]
    push.0.0.0
    # [0, 0, 0, price, price, token_prefix, token_suffix]
    push.5
    # [5, 0, 0, 0, price, price, token_prefix, token_suffix]
    exec.account::set_item
    # [OLD_PRICE_WORD, price, token_prefix, token_suffix]
    dropw drop
    # [token_prefix, token_suffix]

    exec.note::get_sender
    # [owner_prefix, owner_suffix, token_prefix, token_suffix]
    exec._update_owner
    # [token_prefix, token_suffix]
    exec._set_payment_token
    # []
end

# Input: [PRICE_WORD]
# Output: []
# Only owner can call this function
export.update_price
    exec._assert_only_owner
    # [PRICE_WORD]
    exec._set_price
    # []
end

# Input: [new_owner_prefix, new_owner_suffix]
# Output: []
export.update_owner
    exec._assert_only_owner
    exec._update_owner
end

# Input: []
# Output: []
# Only owner can call this function
export.withdraw_assets
    exec._assert_only_owner
    # []
    ##### TODO
end

# Input: [ASSET]
# Output: [pad(16)]
# Standard Miden wallet interface - receive an asset into the account vault
export.receive_asset
    exec.account::add_asset
    # => [ASSET', pad(12)]

    # drop the final asset
    dropw
    # => [pad(16)]
end

# Input: [NAME]
# Output: []
export.register_name
    # Input: [NAME] - 4 felts representing the name

    # Move NAME down to make room for payment validation
    padw swapw
    # [0, 0, 0, 0, NAME]

    # Validate payment before any state changes
    exec._validate_payment
    # [0, 0, 0, 0, NAME]

    # Restore NAME to top
    swapw dropw
    # [NAME]

    # Validate name length
    dupw
    # [NAME, NAME]
    exec._assert_name_length
    # [NAME, NAME]

    # Check if name is already registered (prevent duplicates)
    exec._assert_name_not_registered
    # [NAME]

    # Get the sender address
    exec.note::get_sender
    # [prefix, suffix, NAME(4)] = 6 elements

    # Check if account already has a name (one name per account)
    # Duplicate prefix, suffix, NAME for the check
    dup.5 dup.5 dup.5 dup.5 dup.5 dup.5
    # [prefix, suffix, NAME, prefix, suffix, NAME]
    exec._assert_not_have_name
    # [NAME, prefix, suffix, NAME] (8 elements)
    # _assert_not_have_name consumes [prefix, suffix, NAME] and returns [NAME]

    # Clean up the extra NAME that was returned
    dropw
    # [prefix, suffix, NAME] = 6 elements

    # Duplicate all for both mappings
    dup.5 dup.5 dup.5 dup.5 dup.5 dup.5
    # [prefix, suffix, NAME, prefix, suffix, NAME] = 12 elements

    # Store Name->ID mapping (slot 3)
    # Need: [NAME(KEY), ADDR(VALUE)] = [NAME, 0, 0, prefix, suffix]
    push.0.0
    # [0, 0, prefix, suffix, NAME, prefix, suffix, NAME] = 14 elements

    # Move the first NAME to the top
    # Positions: [0(0), 0(1), prefix(2), suffix(3), NAME(4-7), prefix(8), suffix(9), NAME(10-13)]
    movup.7 movup.7 movup.7 movup.7
    # [NAME, 0, 0, prefix, suffix, prefix, suffix, NAME] = 14 elements

    exec._write_to_name_map
    # [prefix, suffix, NAME] = 6 elements

    # Store ID->Name mapping (slot 4)
    # Need: [ADDR(KEY), NAME(VALUE)] = [0, 0, prefix, suffix, NAME]
    # We have: [prefix, suffix, NAME]
    push.0.0
    # [0, 0, prefix, suffix, NAME] = 8 elements

    exec._write_to_id_map
    # []
end

# Input: [index]
# Output: [STORAGE_ITEM]
export.read_storage
    exec.account::get_item
end

# Input: [index, KEY]
# Output: [STORAGE_ITEM]
export.read_storage_map
    exec.account::get_map_item
end


# Input: [NAME]
# Output: [1 or 0, VALUE, ZERO_WORD]
export.is_name_registered
    push.3
    # [3, NAME]
    exec.account::get_map_item
    # [VALUE]
    push.0.0.0.0
    # [ZERO_WORD, VALUE]
    eqw
    # [1 or 0] - 1 if value equals zero (not registered), 0 if value exists (registered)
    not
    # [0 or 1] - 0 if not registered, 1 if registered
end

# Input: [addr_prefix, addr_suffix]
# Output: [NAME]
export.get_name
    exec._get_name_by_addr
end

# Input:[NAME]
# Output: [addr_prefix, addr_suffix]
export.get_id
    exec._get_addr_by_name
end

# Direct map write procedure for Name->ID (slot 3)
# Input: [KEY(4), VALUE(4)] on stack
# Returns: []
proc._write_to_name_map
    push.3  # Storage slot 3 for Name->ID mapping
    exec.account::set_map_item
    dropw dropw
end

# Direct map write procedure for ID->Name (slot 4)
# Input: [KEY(4), VALUE(4)] on stack
# Returns: []
proc._write_to_id_map
    push.4  # Storage slot 4 for ID->Name mapping
    exec.account::set_map_item
    dropw dropw
end

# Input: [addr_prefix, addr_suffix]
# Output: [1 or 0, ZERO_WORD, NAME]
export.has_name
    exec._get_name_by_addr
    # [NAME]
    push.0.0.0.0
    # [ZERO_WORD, NAME]
    eqw
    # [1 or 0] - 1 if NAME equals zero (no name), 0 if NAME exists (has name)
    not
    # [0 or 1] - 0 if no name, 1 if has name
end

# Input: [addr_prefix, addr_suffix]
# Output: [NAME]
proc._get_name_by_addr
    push.0.0
    # [0, 0, addr_prefix, addr_suffix]
    push.4
    # [4, 0, 0, addr_prefix, addr_suffix]
    exec.account::get_map_item
    # [VALUE]
end

# Input: [NAME]
# Output: [prefix, suffix]
proc._get_addr_by_name
    push.3
    # [3, NAME]
    exec.account::get_map_item
    # [VALUE]
    drop drop
end

# Input: [NAME]
# Output: []
proc._assert_name_not_registered
    push.3
    # [3, NAME]
    exec.account::get_map_item
    # [VALUE] - returns the value (4 elements)
    push.0.0.0.0
    # [ZERO_WORD, VALUE]
    eqw
    # [result, ZERO_WORD, VALUE] - eqw leaves the compared words on stack
    # Stack: [result, w0, w1, w2, w3, v0, v1, v2, v3, ...]
    # Move result below the 8 elements, drop them, then move result back
    movdn.8
    # [w0, w1, w2, w3, v0, v1, v2, v3, result, ...]
    dropw dropw
    # [result, ...]
    assert.err=NAME_ALREADY_REGISTERED
    # []
end

# Input: [prefix, suffix, NAME]
# Output: [NAME]
proc._assert_not_have_name
    # Stack: [prefix, suffix, n0, n1, n2, n3] (NAME is 4 felts)
    # Need to check if [0, 0, prefix, suffix] exists in slot 4

    # Duplicate NAME to preserve it
    dup.5 dup.5 dup.5 dup.5
    # [n0, n1, n2, n3, prefix, suffix, n0, n1, n2, n3]

    # Move duplicated NAME below prefix/suffix
    movdn.7 movdn.7 movdn.7 movdn.7
    # [prefix, suffix, n0, n1, n2, n3, n0, n1, n2, n3]

    # Build the key: [0, 0, prefix, suffix]
    push.0.0
    # [0, 0, prefix, suffix, n0, n1, n2, n3, n0, n1, n2, n3]

    # Query slot 4 for existing name
    push.4
    # [4, 0, 0, prefix, suffix, n0, n1, n2, n3, n0, n1, n2, n3]
    exec.account::get_map_item
    # [VALUE(4), n0, n1, n2, n3, n0, n1, n2, n3]

    # Check if VALUE is zero (no name registered - this is what we want)
    push.0.0.0.0
    # [ZERO(4), VALUE(4), n0, n1, n2, n3, n0, n1, n2, n3]
    eqw
    # [result, ZERO(4), VALUE(4), n0, n1, n2, n3, n0, n1, n2, n3]
    # eqw returns 1 if equal (account has no name), 0 if not equal (account already has name)

    # Clean up the 8 elements from eqw
    movdn.8
    # [ZERO(4), VALUE(4), result, n0, n1, n2, n3, n0, n1, n2, n3]
    dropw dropw
    # [result, n0, n1, n2, n3, n0, n1, n2, n3]

    # Assert result is 1 (account should NOT have a name already)
    assert.err=ACCOUNT_ALREADY_HAS_NAME
    # [n0, n1, n2, n3, n0, n1, n2, n3]

    # Drop the first copy of NAME (the one we looked up)
    dropw
    # [n0, n1, n2, n3] = NAME (the original input NAME)
end

# Input: [NAME(4)]
# Output: [NAME(4)]
proc._assert_name_length
    # Stack when NAME=[5, 435459550305, 0, 0] is pushed:
    # push.5.435459550305.0.0 creates stack (top to bottom):
    # depth 0: 0, depth 1: 0, depth 2: 435459550305, depth 3: 5(length)

    # Get the length from depth 3
    dup.3
    # [length, 0, 0, 435459550305, 5]

    # Check if length > MAX_NAME_LENGTH
    push.MAX_NAME_LENGTH
    # [20, length, 0, 0, 435459550305, 5]

    # u32gt: pops [b, a] and pushes 1 if a > b, 0 otherwise
    # Stack is [20, length, ...] so it checks if length > 20
    u32gt
    # [result, 0, 0, 435459550305, 5]
    # result is 1 if length > 20 (BAD), 0 if length <= 20 (GOOD)

    # Assert result is 0 (length should be <= 20)
    assertz.err=NAME_LEN_HIGH
    # [0, 0, 435459550305, 5] - original NAME preserved
end

# Input: []
# Output: []
proc._assert_initialized
    push.0
    # [0]
    exec.account::get_item
    # Returns: [0, 0, 0, 0] if NOT initialized, [1, 0, 0, 0] if initialized
    # Stack is now [1, 0, 0, 0] (or [0, 0, 0, 0] if not initialized)
    # The initialized flag is at position 0
    # Check if position 0 is zero (not initialized)
    # assertz will fail if value is NOT zero (i.e., if initialized)
    assertz.err=ALREADY_INITIALIZED
    # Drop the rest of the Word
    drop drop drop
    # []
end

# Input: []
# Output: []
proc._set_initialized
    # We want to store Word [1, 0, 0, 0] at slot 0
    # account::set_item stores in REVERSE: [index, V1, V2, V3, V4] â†’ Word[V4, V3, V2, V1]
    # So to get [1, 0, 0, 0] we need stack: [0, 0, 0, 0, 1]
    push.0.0.0
    # [0, 0, 0]
    push.1
    # [1, 0, 0, 0]
    push.0
    # [0, 1, 0, 0, 0]
    movdn.4
    # [1, 0, 0, 0, 0]
    movup.4
    # [0, 1, 0, 0, 0]
    exec.account::set_item
    # [OLD_WORD]
    dropw
end

# Input: [PRICE_WORD, ...REST] where PRICE_WORD is 4 elements
# Output: [...REST]
proc._set_price
    # [p0, p1, p2, p3, ...REST]
    push.5
    # [5, p0, p1, p2, p3, ...REST]
    exec.account::set_item
    # Consumes [5, p0, p1, p2, p3], returns [old0, old1, old2, old3]
    # Stack: [old0, old1, old2, old3, ...REST]
    dropw
    # [...REST]
end

# Input: []
# Output: [PRICE]
proc._get_price_word
    push.5
    # [5]
    exec.account::get_item
    # [PRICE]
end

# Input: [owner_prefix, owner_suffix] (from note::get_sender which returns prefix, suffix)
# Output: []
proc._update_owner
    swap
    # [owner_suffix, owner_prefix]
    push.0.0
    # [0, 0, owner_suffix, owner_prefix]
    push.1
    # [1, 0, 0, owner_suffix, owner_prefix]
    exec.account::set_item
    # set_item reverses: stores as Word[owner_prefix, owner_suffix, 0, 0]
    # [OLD_VALUE]
    dropw
end

proc._assert_only_owner
    exec.note::get_sender
    push.1
    exec.account::get_item
    drop drop
    dup.1 dup.3
    assert_eq.err=OWNER_PREFIX_MISMATCH
    dup.0 dup.4
    assert_eq.err=OWNER_SUFFIX_MISMATCH
    dropw
end

# Input: [token_prefix, token_suffix]
# Output: []
proc._set_payment_token
    # We want to store Word [token_prefix, token_suffix, 0, 0] at indices [0, 1, 2, 3]
    # account::set_item stores in REVERSE: [index, V1, V2, V3, V4] â†’ Word[V4, V3, V2, V1]
    # So to get [token_prefix, token_suffix, 0, 0] we need stack: [2, 0, 0, token_suffix, token_prefix]
    # Current: [token_prefix, token_suffix]
    swap
    # [token_suffix, token_prefix]
    push.0.0
    # [0, 0, token_suffix, token_prefix]
    push.2
    # [2, 0, 0, token_suffix, token_prefix]
    exec.account::set_item
    dropw
end

# Input: []
# Output: [balance]
proc._get_balance
    push.2
    # [2]
    exec.account::get_item
    # [PAYMENT_TOKEN] - returns Word as stored: [token_prefix, token_suffix, 0, 0]
    drop drop
    # [token_prefix, token_suffix]
    exec.account::get_balance
    # [balance]
end

# Input: []
# Output: []
proc._validate_payment
    exec._get_balance
    # [initial_balance]
    exec.note::add_assets_to_account
    # [initial_balance]
    exec._get_balance
    # [after_balance, initial_balance]
    swap
    # [initial_balance, after_balance]
    u32overflowing_sub # after - initial
    # [overflow, result]
    assertz.err=VALIDATE_SUB_OVERFLOW
    # [result]
    exec._get_price_word
    # [PRICE, result]
    drop drop drop
    # [price, result]
    gte # result >= price
    # [price =< result]
    assert.err=WRONG_AMOUNT_PAID
end

# Input: []
# Output: []
proc._validate_payment_old
    # Get price first to check if payment is required
    exec._get_price_word
    # [PRICE_WORD] where price is at index 3 (top of stack when retrieved via get_item)
    # Stack: [p3, p2, p1, p0] - we stored [100, 0, 0, 0] but get_item returns in reverse

    # Check if price is zero (free registration)
    # Price value is at position 3
    dup.3
    # [price, PRICE_WORD]
    push.0
    # [0, price, PRICE_WORD]
    eq
    # [is_free, PRICE_WORD]

    if.true
        # Price is 0 - no payment required, skip validation
        dropw
        # []
    else
        # Price > 0 - validate payment
        # Extract price value from Word (at position 3 due to reversal)
        dup.3
        # [price, PRICE_WORD]
        movdn.4
        # [PRICE_WORD, price]
        dropw
        # [price]

        # Note: Assets should already be in vault (added by note script before calling register_name)
        # Check if account balance >= price
        exec._get_balance
        # [balance, price]

        # Check if balance >= price
        # gte with stack [b, a] checks if a >= b
        # We have [balance, price] and want to check if balance >= price
        # So we need to swap to get [price, balance]
        swap
        # [price, balance]
        gte
        # [balance >= price]  (result of: balance >= price)
        assert.err=WRONG_AMOUNT_PAID
    end
end
